<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="杨佳男">





<title>JAVA | 勤练带来力量</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">YangJianan&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">归 档</a>
                
                    <a class="menu-item" href="/categories">分 类</a>
                
                    <a class="menu-item" href="/tags">标 签</a>
                
                    <a class="menu-item" href="/about">关 于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">YangJianan&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">归 档</a>
                
                    <a class="menu-item" href="/categories">分 类</a>
                
                    <a class="menu-item" href="/tags">标 签</a>
                
                    <a class="menu-item" href="/about">关 于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">JAVA</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">杨佳男</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">2018-10-26&nbsp;&nbsp;21:54:22</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><table>
<thead>
<tr>
<th>类型</th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private</td>
<td>私有的</td>
</tr>
<tr>
<td></td>
<td>protected</td>
<td>受保护的</td>
</tr>
<tr>
<td></td>
<td>public</td>
<td>公共的</td>
</tr>
<tr>
<td>类、方法和变量修饰符</td>
<td>abstract</td>
<td>声明抽象</td>
</tr>
<tr>
<td></td>
<td>class</td>
<td>类</td>
</tr>
<tr>
<td></td>
<td>extends</td>
<td>扩充,继承</td>
</tr>
<tr>
<td></td>
<td>final</td>
<td>最终值,不可改变的</td>
</tr>
<tr>
<td></td>
<td>implements</td>
<td>实现（接口）</td>
</tr>
<tr>
<td></td>
<td>interface</td>
<td>接口</td>
</tr>
<tr>
<td></td>
<td>native</td>
<td>本地，原生方法（非Java实现）</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>新,创建</td>
</tr>
<tr>
<td></td>
<td>static</td>
<td>静态</td>
</tr>
<tr>
<td></td>
<td>strictfp</td>
<td>严格,精准</td>
</tr>
<tr>
<td></td>
<td>synchronized</td>
<td>线程,同步</td>
</tr>
<tr>
<td></td>
<td>transient</td>
<td>短暂</td>
</tr>
<tr>
<td></td>
<td>volatile</td>
<td>易失</td>
</tr>
<tr>
<td>程序控制语句</td>
<td>break</td>
<td>跳出循环</td>
</tr>
<tr>
<td></td>
<td>case</td>
<td>定义一个值以供switch选择</td>
</tr>
<tr>
<td></td>
<td>continue</td>
<td>继续</td>
</tr>
<tr>
<td></td>
<td>default</td>
<td>默认</td>
</tr>
<tr>
<td></td>
<td>do</td>
<td>运行</td>
</tr>
<tr>
<td></td>
<td>else</td>
<td>否则</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>循环</td>
</tr>
<tr>
<td></td>
<td>if</td>
<td>如果</td>
</tr>
<tr>
<td></td>
<td>instanceof</td>
<td>实例</td>
</tr>
<tr>
<td></td>
<td>return</td>
<td>返回</td>
</tr>
<tr>
<td></td>
<td>switch</td>
<td>根据值选择执行</td>
</tr>
<tr>
<td></td>
<td>while</td>
<td>循环</td>
</tr>
<tr>
<td>错误处理</td>
<td>assert</td>
<td>断言表达式是否为真</td>
</tr>
<tr>
<td></td>
<td>catch</td>
<td>捕捉异常</td>
</tr>
<tr>
<td></td>
<td>finally</td>
<td>有没有异常都执行</td>
</tr>
<tr>
<td></td>
<td>throw</td>
<td>抛出一个异常对象</td>
</tr>
<tr>
<td></td>
<td>throws</td>
<td>声明一个异常可能被抛出</td>
</tr>
<tr>
<td></td>
<td>try</td>
<td>捕获异常</td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>引入</td>
</tr>
<tr>
<td></td>
<td>package</td>
<td>包</td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>布尔型</td>
</tr>
<tr>
<td></td>
<td>byte</td>
<td>字节型</td>
</tr>
<tr>
<td></td>
<td>char</td>
<td>字符型</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>双精度浮点</td>
</tr>
<tr>
<td></td>
<td>float</td>
<td>单精度浮点</td>
</tr>
<tr>
<td></td>
<td>int</td>
<td>整型</td>
</tr>
<tr>
<td></td>
<td>long</td>
<td>长整型</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>短整型</td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>父类,超类</td>
</tr>
<tr>
<td></td>
<td>this</td>
<td>本类</td>
</tr>
<tr>
<td></td>
<td>void</td>
<td>无返回值</td>
</tr>
<tr>
<td>保留关键字</td>
<td>goto</td>
<td>是关键字，但不能使用</td>
</tr>
<tr>
<td></td>
<td>const</td>
<td>是关键字，但不能使用</td>
</tr>
<tr>
<td></td>
<td>null</td>
<td>空</td>
</tr>
</tbody></table>
<h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。</span><br><span class="line">类：类是一个模板，它描述一类对象的行为和状态。</span><br><span class="line">软件对象的状态就是属性，行为通过方法体现。</span><br><span class="line">软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</span><br><span class="line">通过下面一个简单的类来理解下Java中类的定义：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123; String breed; <span class="keyword">int</span> age; String color; <span class="function"><span class="keyword">void</span> <span class="title">barking</span><span class="params">()</span></span>&#123; &#125; <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123; &#125; <span class="function"><span class="keyword">void</span> <span class="title">sleeping</span><span class="params">()</span></span>&#123; &#125; &#125;</span><br><span class="line">一个类可以包含以下类型变量：</span><br><span class="line">• 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</span><br><span class="line">• 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</span><br><span class="line">• 类变量：类变量也声明在类中，方法体之外，但必须声明为<span class="keyword">static</span>类型。</span><br><span class="line">一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。 </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">构造方法</span><br><span class="line">每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。</span><br><span class="line">在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</span><br><span class="line">下面是一个构造方法示例：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123; <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">()</span></span>&#123; &#125; <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123; <span class="comment">// 这个构造器仅有一个参数：name &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">创建对象</span><br><span class="line">对象是根据类创建的。在Java中，使用关键字<span class="keyword">new</span>来创建一个新的对象。创建对象需要以下三步：</span><br><span class="line">• 声明：声明一个对象，包括对象名称和对象类型。</span><br><span class="line">• 实例化：使用关键字<span class="keyword">new</span>来创建一个对象。</span><br><span class="line">• 初始化：使用<span class="keyword">new</span>创建对象时，会调用构造方法初始化对象。</span><br><span class="line">下面是一个创建对象的例子：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123; <span class="comment">//这个构造器仅有一个参数：name System.out.println(&quot;小狗的名字是 : &quot; + name ); &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123; <span class="comment">// 下面的语句将创建一个Puppy对象 </span></span><br><span class="line">Puppy myPuppy = <span class="keyword">new</span> Puppy( <span class="string">&quot;tommy&quot;</span> ); &#125; &#125;</span><br><span class="line"></span><br><span class="line">访问实例变量和方法</span><br><span class="line">通过已创建的对象来访问成员变量和成员方法，如下所示：</span><br><span class="line"><span class="comment">/* 实例化对象 */</span> ObjectReference = <span class="keyword">new</span> Constructor();</span><br><span class="line"> <span class="comment">/* 访问类中的变量 */</span> ObjectReference.variableName; </span><br><span class="line"><span class="comment">/* 访问类中的方法 */</span> ObjectReference.methodName();</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">下面的例子展示如何访问实例变量和调用成员方法：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> puppyAge; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"> <span class="comment">// 这个构造器仅有一个参数：name System.out.println(&quot;小狗的名字是 : &quot; + name ); </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">( <span class="keyword">int</span> age )</span></span>&#123; puppyAge = age; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">( )</span></span>&#123; System.out.println(<span class="string">&quot;小狗的年龄为 : &quot;</span> + puppyAge ); <span class="keyword">return</span> puppyAge; &#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"> <span class="comment">/* 创建对象 */</span> Puppy myPuppy = <span class="keyword">new</span> Puppy( <span class="string">&quot;tommy&quot;</span> );</span><br><span class="line"> <span class="comment">/* 通过方法来设定age */</span> myPuppy.setAge( <span class="number">2</span> ); </span><br><span class="line"><span class="comment">/* 调用另一个方法获取age */</span> myPuppy.getAge( ); </span><br><span class="line"><span class="comment">/*你也可以像下面这样访问成员变量 */</span> System.out.println(<span class="string">&quot;变量值 : &quot;</span> + myPuppy.puppyAge ); &#125; &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
<p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
<p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
<p>Java 的两大数据类型:</p>
<ul>
<li>内置数据类型</li>
<li>引用数据类型</li>
</ul>
<p><strong>内置数据类型</strong></p>
<p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<p><strong>byte：</strong></p>
<ul>
<li>byte     数据类型是8位、有符号的，以二进制补码表示的整数；</li>
<li>最小值是 <strong>-128（-2^7）</strong>；</li>
<li>最大值是 <strong>127（2^7-1）</strong>；</li>
<li>默认值是 <strong>0</strong>；</li>
<li>byte     类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li>
<li>例子：byte a = 100，byte     b = -50。</li>
</ul>
<p><strong>short：</strong></p>
<ul>
<li>short 数据类型是 16     位、有符号的以二进制补码表示的整数</li>
<li>最小值是 <strong>-32768（-2^15）</strong>；</li>
<li>最大值是 <strong>32767（2^15 - 1）</strong>；</li>
<li>Short 数据类型也可以像 byte     那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
<li>默认值是 <strong>0</strong>；</li>
<li>例子：short s =     1000，short r = -20000。</li>
</ul>
<p><strong>int：</strong></p>
<ul>
<li>int     数据类型是32位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li>
<li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li>
<li>一般地整型变量默认为 int 类型；</li>
<li>默认值是 <strong>0</strong> ；</li>
<li>例子：int a = 100000,     int b = -200000。</li>
</ul>
<p><strong>long：</strong></p>
<ul>
<li>long 数据类型是 64     位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li>
<li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是 <strong>0L</strong>；</li>
<li>例子： long a =     100000L，Long b = -200000L。<pre><code>          &quot;L&quot;理论上不分大小写，但是若写成&quot;l&quot;容易与数字&quot;1&quot;混淆，不容易分辩。所以最好大写。     
</code></pre>
</li>
</ul>
<p><strong>float：</strong></p>
<ul>
<li>float     数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>
<li>float     在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是 <strong>0.0f</strong>；</li>
<li>浮点数不能用来表示精确的值，如货币；</li>
<li>例子：float f1 =     234.5f。</li>
</ul>
<p><strong>double：</strong></p>
<ul>
<li>double 数据类型是双精度、64     位、符合IEEE 754标准的浮点数；</li>
<li>浮点数的默认类型为double类型；</li>
<li>double类型同样不能表示精确的值，如货币；</li>
<li>默认值是 <strong>0.0d</strong>；</li>
<li>例子：double d1 =     123.4。</li>
</ul>
<p><strong>boolean：</strong></p>
<ul>
<li>boolean数据类型表示一位的信息；</li>
<li>只有两个取值：true 和 false；</li>
<li>这种类型只作为一种标志来记录     true/false 情况；</li>
<li>默认值是 <strong>false</strong>；</li>
<li>例子：boolean one =     true。</li>
</ul>
<p><strong>char：</strong></p>
<ul>
<li>char类型是一个单一的 16 位     Unicode 字符；</li>
<li>最小值是 <strong>\u0000</strong>（即为0）；</li>
<li>最大值是 <strong>\uffff</strong>（即为65,535）；</li>
<li>char 数据类型可以储存任何字符；</li>
<li>例子：char letter =     ‘A’;。</li>
</ul>
<p><strong>自动类型转换</strong></p>
<p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p>
<p>转换从低级到高级。</p>
<p>低 ————————————&gt; 高</p>
<p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double </p>
<p>数据类型转换必须满足如下规则：</p>
<ul>
<li>不能对boolean类型进行类型转换。</li>
<li>不能把对象类型转换成不相关类的对象。</li>
<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>
<li>转换过程中可能导致溢出或损失精度</li>
</ul>
<p><strong>强制类型转换</strong></p>
<ul>
<li>条件是转换的数据类型必须是兼容的。</li>
<li>格式：(type)value     type是要强制类型转换后的数据类型</li>
</ul>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>类变量（静态变量）：独立于方法之外的变量，用 static 修饰。</p>
<ul>
<li>类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。</li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li>
<li>静态变量在第一次被访问时创建，在程序结束时销毁。</li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li>
<li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
<li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li>
<li>类变量被声明为public static     final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>
</ul>
<p>实例变量：独立于方法之外的变量，不过没有 static 修饰。 </p>
<ul>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li>
<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li>
<li>实例变量可以声明在使用前或者使用后；</li>
<li>访问修饰符可以修饰实例变量；</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。     </li>
</ul>
<p>局部变量：类的方法中的变量。</p>
<ul>
<li>局部变量声明在方法、构造方法或者语句块中；</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li>
<li>访问修饰符不能用于局部变量；</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><strong>访问控制修饰符</strong> </p>
<p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<ul>
<li><strong>default</strong> (即缺省，什么也不写）:     在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li><strong>private</strong> :     在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>
<li><strong>public</strong> :     对所有类可见。使用对象：类、接口、变量、方法</li>
<li><strong>protected</strong> :     对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li>
</ul>
<p><strong>访问控制和继承</strong></p>
<p>请注意以下方法继承的规则：</p>
<ul>
<li>父类中声明为 public     的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected     的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private     的方法，不能够被继承。</li>
</ul>
<p><strong>非访问修饰符</strong></p>
<p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p>
<p>static 修饰符，用来修饰类方法和类变量。</p>
<p>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>
<p>abstract 修饰符，用来创建抽象类和抽象方法。</p>
<p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p>
<p><strong>static 修饰符</strong></p>
<ul>
<li>**静态变量：<br>**          static     关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static     变量。 </li>
<li>**静态方法：<br>**          static     关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 </li>
</ul>
<p>对类变量和方法的访问可以直接使用 <strong>classname.variablename</strong> 和 <strong>classname.methodname</strong> 的方式访问。 </p>
<p><strong>final 修饰符</strong></p>
<p><strong>final 变量：</strong></p>
<p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p>
<p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>
<p><strong>抽象类：</strong></p>
<p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p>
<p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 </p>
<p>抽象类可以包含抽象方法和非抽象方法。</p>
<p><strong>抽象方法</strong></p>
<p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p>
<p>抽象方法不能被声明成 final 和 static。 </p>
<p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p>
<p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p>
<p>抽象方法的声明以分号结尾，例如：**public abstract sample();**。 </p>
<p><strong>volatile 修饰符</strong></p>
<p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>一个 volatile 对象引用可能是 null。 </p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。</p>
<p><strong>算术运算符</strong></p>
<p>算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。</p>
<table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>描述</strong></th>
<th><strong>例子</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法 -  相加运算符两侧的值</td>
<td>A + B 等于  30</td>
</tr>
<tr>
<td>-</td>
<td>减法 -  左操作数减去右操作数</td>
<td>A – B 等于  -10</td>
</tr>
<tr>
<td>*</td>
<td>乘法 -  相乘操作符两侧的值</td>
<td>A *  B等于200</td>
</tr>
<tr>
<td>/</td>
<td>除法 -  左操作数除以右操作数</td>
<td>B / A等于2</td>
</tr>
<tr>
<td>％</td>
<td>取余 -  左操作数除以右操作数的余数</td>
<td>B%A等于0</td>
</tr>
<tr>
<td>++</td>
<td>自增:  操作数的值增加1</td>
<td>B++ 或  ++B 等于 21（区别详见下文）</td>
</tr>
<tr>
<td>–</td>
<td>自减:  操作数的值减少1</td>
<td>B– 或  –B 等于 19（区别详见下文）</td>
</tr>
</tbody></table>
<p><strong>关系运算符</strong></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th><strong>例子</strong></th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>检查如果两个操作数的值是否相等，如果相等则条件为真。</td>
<td>（A ==  B）为假(非真)。</td>
</tr>
<tr>
<td>!=</td>
<td>检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td>
<td>(A != B)  为真。</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td>
<td>（A&gt;  B）非真。</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td>
<td>（A  &lt;B）为真。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td>
<td>（A&gt; =  B）为假。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td>
<td>（A &lt;=  B）为真。</td>
</tr>
</tbody></table>
<p><strong>位运算符</strong></p>
<table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>描述</strong></th>
<th><strong>例子</strong></th>
</tr>
</thead>
<tbody><tr>
<td>＆</td>
<td>如果相对应位都是1，则结果为1，否则为0</td>
<td>（A＆B），得到12，即0000  1100</td>
</tr>
<tr>
<td>|</td>
<td>如果相对应位都是0，则结果为0，否则为1</td>
<td>（A |  B）得到61，即 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>如果相对应位值相同，则结果为0，否则为1</td>
<td>（A ^  B）得到49，即 0011 0001</td>
</tr>
<tr>
<td>〜</td>
<td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td>
<td>（〜A）得到-61，即1100  0011</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td>
<td>A  &lt;&lt; 2得到240，即 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td>
<td>A  &gt;&gt; 2得到15即 1111</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td>
<td>A&gt;&gt;&gt;2得到15即0000  1111</td>
</tr>
</tbody></table>
<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>描述</strong></th>
<th><strong>例子</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td>
<td>（A  &amp;&amp; B）为假。</td>
</tr>
<tr>
<td>| |</td>
<td>称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td>
<td>（A | |  B）为真。</td>
</tr>
<tr>
<td>！</td>
<td>称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td>
<td>！（A  &amp;&amp; B）为真。</td>
</tr>
</tbody></table>
<p><strong>赋值运算符</strong></p>
<table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>描述</strong></th>
<th><strong>例子</strong></th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>简单的赋值运算符，将右操作数的值赋给左侧操作数</td>
<td>C = A +  B将把A + B得到的值赋给C</td>
</tr>
<tr>
<td>+ =</td>
<td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td>
<td>C + =  A等价于C = C + A</td>
</tr>
<tr>
<td>- =</td>
<td>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td>
<td>C - =  A等价于C = C -   A</td>
</tr>
<tr>
<td>* =</td>
<td>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td>
<td>C * =  A等价于C = C * A</td>
</tr>
<tr>
<td>/ =</td>
<td>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td>
<td>C / =  A等价于C = C / A</td>
</tr>
<tr>
<td>（％）=</td>
<td>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td>
<td>C％=  A等价于C = C％A</td>
</tr>
<tr>
<td>&lt;&lt;  =</td>
<td>左移位赋值运算符</td>
<td>C  &lt;&lt; = 2等价于C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;  =</td>
<td>右移位赋值运算符</td>
<td>C  &gt;&gt; = 2等价于C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>＆=</td>
<td>按位与赋值运算符</td>
<td>C＆=  2等价于C = C＆2</td>
</tr>
<tr>
<td>^ =</td>
<td>按位异或赋值操作符</td>
<td>C ^ =  2等价于C = C ^ 2</td>
</tr>
<tr>
<td>| =</td>
<td>按位或赋值操作符</td>
<td>C | =  2等价于C = C | 2</td>
</tr>
</tbody></table>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>操作符</strong></th>
<th><strong>关联性</strong></th>
</tr>
</thead>
<tbody><tr>
<td>后缀</td>
<td>() [] .  (点操作符)</td>
<td>左到右</td>
</tr>
<tr>
<td>一元</td>
<td>+ + - ！〜</td>
<td>从右到左</td>
</tr>
<tr>
<td>乘性</td>
<td>* /％</td>
<td>左到右</td>
</tr>
<tr>
<td>加性</td>
<td>+ -</td>
<td>左到右</td>
</tr>
<tr>
<td>移位</td>
<td>&gt;&gt;  &gt;&gt;&gt;  &lt;&lt;</td>
<td>左到右</td>
</tr>
<tr>
<td>关系</td>
<td>&gt;&gt;  = &lt;&lt; =</td>
<td>左到右</td>
</tr>
<tr>
<td>相等</td>
<td>==   !=</td>
<td>左到右</td>
</tr>
<tr>
<td>按位与</td>
<td>＆</td>
<td>左到右</td>
</tr>
<tr>
<td>按位异或</td>
<td>^</td>
<td>左到右</td>
</tr>
<tr>
<td>按位或</td>
<td>|</td>
<td>左到右</td>
</tr>
<tr>
<td>逻辑与</td>
<td>&amp;&amp;</td>
<td>左到右</td>
</tr>
<tr>
<td>逻辑或</td>
<td>| |</td>
<td>左到右</td>
</tr>
<tr>
<td>条件</td>
<td>？：</td>
<td>从右到左</td>
</tr>
<tr>
<td>赋值</td>
<td>= + = -  = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =</td>
<td>从右到左</td>
</tr>
<tr>
<td>逗号</td>
<td>，</td>
<td>左到右</td>
</tr>
</tbody></table>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。</p>
<p>Java中有三种主要的循环结构：</p>
<p><strong>while</strong> 循环</p>
<p><strong>do…while</strong> 循环</p>
<p><strong>for</strong> 循环</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式 <span class="number">1</span>)</span><br><span class="line">&#123; <span class="comment">//如果布尔表达式 1的值为true执行代码 &#125;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式 <span class="number">2</span>)</span><br><span class="line">&#123; <span class="comment">//如果布尔表达式 2的值为true执行代码 &#125;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式 <span class="number">3</span>)&#123; <span class="comment">//如果布尔表达式 3的值为true执行代码 &#125;</span></span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//如果以上布尔表达式都不为true执行代码 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p><strong>继承的特性</strong></p>
<ul>
<li>子类拥有父类非private的属性，方法。</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
<li>Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。</li>
<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li>
</ul>
<p><strong>继承关键字</strong> </p>
<p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p>
<p><strong>extends关键字</strong></p>
<p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>
<p><strong>implements关键字</strong></p>
<p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
<p><strong>super 与 this 关键字</strong></p>
<p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
<p>this关键字：指向自己的引用。</p>
<p><strong>final关键字</strong></p>
<p>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：</p>
<ul>
<li>声明类：<pre><code>      final class 类名 &#123;//类体&#125;
</code></pre>
</li>
<li>声明方法：<pre><code>      修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125;
</code></pre>
</li>
</ul>
<p><strong>注</strong>:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作。</p>
<p><strong>多态的优点</strong> </p>
<ul>
<li>\1. 消除类型之间的耦合关系</li>
<li>\2. 可替换性</li>
<li>\3. 可扩充性</li>
<li>\4. 接口性</li>
<li>\5. 灵活性</li>
<li>\6. 简化性</li>
</ul>
<p><strong>多态存在的三个必要条件</strong></p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/02/23/%E5%85%B6%E4%BB%96%E4%B8%8D%E6%B5%81%E8%A1%8C%E5%B7%A5%E5%85%B7/">一些没用的工具</a>
            
            
            <a class="next" rel="next" href="/2018/08/21/hello-world/">Hello World</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 杨佳男 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>